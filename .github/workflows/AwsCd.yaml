name: AWS CD
run-name: Build, deploy, and provision AWS

on:
  push:
    branches:
      - main
      - staging
      - testing
  workflow_dispatch:
    inputs:
      forceSync:
        description: "Overwrite all remote content with this build (purge staging/testing)"
        type: boolean
        required: false

# Required for aws-actions/configure-aws-credentials
permissions:
  id-token: write
  contents: read

env:
  BUCKET_PREFIX: dsire-api
  DEPENDENCY_LAYER_NAME: HandlerDependencies

jobs:

  build-packages:
    name: Build API & package for Lambda
    runs-on: ubuntu-latest
    environment: AWS_Development

    steps:
      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Install Node.js version ${{ vars.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ vars.NODE_VERSION }}

      - name: Set NODE_ENV for development
        run: echo "NODE_ENV=development" >> $GITHUB_ENV
        if: github.ref_name == 'testing'

      - name: Set NODE_ENV for production
        run: echo "NODE_ENV=production" >> $GITHUB_ENV
        if: github.ref_name != 'testing'

      - name: Install dependencies for development
        env:
          NODE_ENV: development
        run: npm ci --prefix api/
        if: github.ref_name == 'testing'

      - name: Install dependencies for production
        env:
          NODE_ENV: production
        run: npm ci --prefix api/
        if: github.ref_name != 'testing'

      - name: Generate Prisma client
        run: cd api; npx prisma generate; cd ..

      - name: Compile TypeScript
        run: cd api; npx tsc -p tsconfig.json; cd ..

      - name: Zip API package api-${{ github.ref_name }}
        run: cd dist/api/src; shopt -s globstar && zip ../../api-"${{ github.ref_name }}".zip **; cd ../../..

      - name: Upload API package as artifact
        uses: actions/upload-artifact@v3
        with:
          name: api-${{ github.ref_name }}
          path: dist/api-*.zip

      - name: Zip dependency package
        run: >
          mkdir -p dist/api/nodejs/node18/ &&
          ln -s ../../../../api/node_modules dist/api/nodejs/node18/ &&
          cd dist/api; zip -r ../../dist/api-dependencies.zip nodejs; cd ..

      - name: Upload dependency package as artifact
        uses: actions/upload-artifact@v3
        with:
          name: api-dependencies
          path: dist/api-dependencies.zip

  sync-deploy-dependency-package:
    name: Deploy Lambda dependency layer
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - build-packages
      - cloudformation
    outputs:
      DEPENDENCY_LAYER_ARN_VERSION_ENC_BASE64: ${{ steps.create-layer.outputs.DEPENDENCY_LAYER_ARN_VERSION_ENC_BASE64 }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}

      - name: Download dependency package as artifact
        uses: actions/download-artifact@v3
        with:
          name: api-dependencies
          path: dist/

      - name: Create new Lambda layer with dependency package
        id: create-layer
        # AWS account IDs (embedded in the versioned layer ARN) are worth keeping
        # secret (and GitHub will obfuscate any output with one in plaintext),
        # so kick the ARN through symmetric GPG with our signing secret and Base64 the
        # binary to keep things easy before outputting it
        run: |
          echo "Syncing dependency package with S3"
          aws s3 sync dist/ s3://"${{ env.BUCKET_PREFIX }}"-packages --exclude "*" --include "api-dependencies.zip" --size-only
          echo 'Creating dependency layer from this dependency package'
          echo '(encrypting versioned ARN with signing secret to Base64 output)'
          echo "DEPENDENCY_LAYER_ARN_VERSION_ENC_BASE64=$(aws lambda publish-layer-version \
              --layer-name "${{ env.DEPENDENCY_LAYER_NAME }}" \
              --content S3Bucket="${{ env.BUCKET_PREFIX }}"-packages,S3Key=api-dependencies.zip \
              --compatible-architectures "x86_64" \
              --compatible-runtimes "nodejs18.x" \
              --description "node_modules for the DSIRE API" \
              --query LayerVersionArn \
              --output text \
              | gpg -co - --batch --passphrase "${{ secrets.SIGNING_SECRET }}" \
              | base64 -w 0)" >> $GITHUB_OUTPUT

  sync-package:
    name: Sync API package with S3
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - build-packages
      - cloudformation

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}

      - name: Download API package as artifact
        uses: actions/download-artifact@v3
        with:
          name: api-${{ github.ref_name }}
          path: dist/

      - name: Sync package with S3
        run: |
          STAGES=( main staging testing )
          for stage in "${STAGES[@]}"; do
              if [ "${stage}" == "${{ github.ref_name }}" ] || ! aws s3 ls s3://"${{ env.BUCKET_PREFIX }}"-packages | grep "${stage}" || [ "${{ inputs.forceSync }}" == "true" ]; then
                  echo "Package for stage ${stage} was updated or missing; it will be replaced by this package"
                  [ "${{ inputs.forceSync }}" == "true" ] && echo "(forced)"
                  ln -s api-"${{ github.ref_name }}".zip api-"${stage}".zip
                  aws s3 sync dist/ s3://"${{ env.BUCKET_PREFIX }}"-packages --exclude "*" --include "api-${stage}.zip"
              fi
          done

  deploy-package:
      name: Deploy API package on Lambda
      runs-on: ubuntu-latest
      environment: AWS_Development
      needs:
        - sync-deploy-dependency-package
        - sync-package

      steps:
        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v1
          with:
            aws-region: ${{ vars.AWS_REGION }}
            role-to-assume: ${{ vars.AWS_ROLE_ARN }}

        - name: Deploy package on Lambda
          run: |
            # TODO pragma this business?
            declare -A STAGES_LAMBDAS=( [main]=MainHandler [staging]=StagingHandler [testing]=TestingHandler )
            STAGES=( main staging testing )
            for stage in "${STAGES[@]}"; do
                if [ "${stage}" == "${{ github.ref_name }}" ] || [ "${{ inputs.forceSync }}" == "true" ]; then
                    echo "Deploying package api-"${{ github.ref_name }}" in stage ${stage} on this dependency layer"
                    [ "${{ inputs.forceSync }}" == "true" ] && echo "(forced)"
                    aws lambda update-function-code --function-name "${STAGES_LAMBDAS[$stage]}" --s3-bucket "${{ env.BUCKET_PREFIX }}"-packages --s3-key api-"${stage}".zip > /dev/null
                    aws lambda wait function-updated --function-name "${STAGES_LAMBDAS[$stage]}"
                    aws lambda update-function-configuration --function-name "${STAGES_LAMBDAS[$stage]}" --layers $(base64 -d <<< "${{ needs.sync-deploy-dependency-package.outputs.DEPENDENCY_LAYER_ARN_VERSION_ENC_BASE64 }}" | gpg -dqo - --batch --passphrase "${{ secrets.SIGNING_SECRET }}") > /dev/null
                fi
            done

  sync-environment-lambda:
    name: Sync secrets with Lambda
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - cloudformation

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}

      - name: Get root API URL (for setting $ROOT_API_URL)
        run: echo "ROOT_API_URL=$(aws cloudformation list-exports --query "Exports[?Name=='ApiUrl'].Value" --no-paginate --output text)" >> $GITHUB_ENV
      - name: Sync all environment secrets with Lambda handlers
        env:
          APPROVER_EMAIL_MAIN: ${{ secrets.APPROVER_EMAIL_MAIN }}
          APPROVER_EMAIL_STAGING: ${{ secrets.APPROVER_EMAIL_STAGING }}
          APPROVER_EMAIL_TESTING: ${{ secrets.APPROVER_EMAIL_TESTING }}
          DB_URI: ${{ secrets.DB_URI }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          IDENTITY_EMAIL: ${{ secrets.IDENTITY_EMAIL }}
          NODE_OPTIONS: ${{ vars.NODE_OPTIONS }}
          PUBLIC_KEY: ${{ vars.PUBLIC_KEY_JWK }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY_JWK }}
          ROOT_API_URL: ${{ env.ROOT_API_URL }}
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        run: |
          # Syncs from the environment to all lambdas...
          # $APPROVER_EMAIL_$GITHUB_REF_NAME as APPROVER_EMAIL (on the lambda/stage matching $GITHUB_REF_NAME)
          # $DB_URI                          as DB_URI
          # $GITHUB_REF_NAME                 as STAGE
          # $IDENTITY_EMAIL                  as IDENTITY_EMAIL
          # $NODE_ENV                        as NODE_ENV
          # $NODE_OPTIONS                    as NODE_OPTIONS
          # $PUBLIC_KEY                      as PUBLIC_KEY
          # $PRIVATE_KEY                     as PRIVATE_KEY
          # $SIGNING_SECRET                  as SIGNING_SECRET
          # $SMTP_USERNAME                   as SMTP_USERNAME
          # $SMTP_PASSWORD                   as SMTP_PASSWORD
          declare -A STAGES_LAMBDAS=( [main]=MainHandler [staging]=StagingHandler [testing]=TestingHandler )
          declare -A STAGES_APPROVER_EMAILS=( [main]=APPROVER_EMAIL_MAIN [staging]=APPROVER_EMAIL_STAGING [testing]=APPROVER_EMAIL_TESTING )
          STAGES=( main staging testing )
          for stage in "${STAGES[@]}"; do
              aws lambda update-function-configuration \
                  --function-name "${STAGES_LAMBDAS[$stage]}" \
                  --environment "Variables={APPROVER_EMAIL='${!STAGES_APPROVER_EMAILS[$stage]}',
                                            DB_URI='${DB_URI}',
                                            IDENTITY_EMAIL='${IDENTITY_EMAIL}',
                                            NODE_OPTIONS='${NODE_OPTIONS}',
                                            PUBLIC_KEY='${PUBLIC_KEY}',
                                            PRIVATE_KEY='${PRIVATE_KEY}',
                                            ROOT_API_URL='${ROOT_API_URL}',
                                            SIGNING_SECRET='${SIGNING_SECRET}',
                                            SMTP_USERNAME='${SMTP_USERNAME}',
                                            SMTP_PASSWORD='${SMTP_PASSWORD}',
                                            STAGE='${stage}'}" > /dev/null
              aws lambda wait function-updated --function-name "${STAGES_LAMBDAS[$stage]}"
          done

  render-sync-content-s3:
    name: Render & sync content with S3
    runs-on: ubuntu-latest
    environment: AWS_Development

    steps:
      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Copy content to distribution context
        run: mkdir -p dist/frontend && cp -r frontend dist/

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
      - name: Get root API URL (for setting $ROOT_API_URL)
        run: echo "ROOT_API_URL=$(aws cloudformation list-exports --query "Exports[?Name=='ApiUrl'].Value" --no-paginate --output text)" >> $GITHUB_ENV
      - name: Render and sync content with S3
        run: |
          # Templating: replace...
          # {% STAGE %} with ${{ github.ref_name }} if ${{ github.ref_name }} != 'main'
          # {% COMMIT_HASH_SHORT %} with the first 7 characters of $GITHUB_SHA
          # {$ API_URL %} with $ROOT_API_URL/$GITHUB_REF_NAME
          declare -A TOKENS_REPLACEMENTS
          TOKENS_REPLACEMENTS[{% STAGE %}]="${GITHUB_REF_NAME#main}"
          TOKENS_REPLACEMENTS[{% COMMIT_HASH_SHORT %}]="${GITHUB_SHA:0:7}"
          TOKENS_REPLACEMENTS[{% API_URL %}]="${ROOT_API_URL}/${GITHUB_REF_NAME}"
          for view in dist/frontend/*.html; do
              for token in "${!TOKENS_REPLACEMENTS[@]}"; do
                  sed -i -e "s~${token}~${TOKENS_REPLACEMENTS[$token]}~g" "${view}"
              done
          done
          STAGES=( main staging testing )
          for stage in "${STAGES[@]}"; do
              # TODO better way to check if host empty than assuming filled on any HTML file
              if [ "${stage}" == "${{ github.ref_name }}" ] || ! aws s3 ls s3://"${{ env.BUCKET_PREFIX }}"-hosting-"${stage}" | grep html || [ "${{ inputs.forceSync }}" == "true" ]; then
                  echo "Content for stage ${stage} was updated or missing; it will be replaced by this content"
                  [ "${{ inputs.forceSync }}" == "true" ] && echo "(forced)"
                  aws s3 sync --delete dist/frontend s3://"${{ env.BUCKET_PREFIX }}"-hosting-"${stage}"
              fi
          done

      - name: Upload content as artifact
        uses: actions/upload-artifact@v3
        with:
          name: frontend-${{ github.ref_name }}
          path: dist/frontend/*

  cloudformation:
    name: Deploy CloudFormation stacks
    runs-on: ubuntu-latest
    environment: AWS_Development

    steps:
      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
      - name: Deploy GitHubActionsCd & DsireApi stacks
        run: |
          aws cloudformation deploy --template-file aws/CloudFormation/GitHubActionsCd.yaml --tags product=DsireApi --stack-name GitHubActionsCd --capabilities CAPABILITY_NAMED_IAM
          aws cloudformation deploy --template-file aws/CloudFormation/DsireApi.yaml --tags product=DsireApi --stack-name DsireApi --capabilities CAPABILITY_NAMED_IAM
