name: AWS Deploy
run-name: Create deployment on AWS

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - preview/**

# Required for aws-actions/configure-aws-credentials
permissions:
  id-token: write
  contents: read


jobs:

  get-names:
    name: Get deployment names
    runs-on: ubuntu-latest
    environment: AWS_Development
    outputs:
      NAME: ${{ steps.get-name.outputs.NAME }}
      HANDLER: DsireApi_${{ steps.get-name.outputs.NAME }}
      HANDLER_STACK: DsireApi-${{ steps.get-name.outputs.NAME }}

    steps:

      - name: Generate deployment names for branch ${{ github.ref_name }} (${{ github.event.ref }})
        id: get-name
        env:
          SED_REF_NAME: s~refs/heads/~~g; s~\.~-~g; s~_~-~g; s~/~-~g
        run: |
          NAME=$(echo "${{ github.ref_name }}" | sed "${SED_REF_NAME}")
          echo "NAME=${NAME}" >> $GITHUB_OUTPUT

  get-urls:
    name: Get AWS URLs
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs: get-names
    outputs:
      API: ${{ steps.get-api-url.outputs.ROOT_API_URL }}/${{ needs.get-names.outputs.NAME }}
      HOSTING: ${{ steps.get-hosting-url.outputs.ROOT_HOSTING_URL }}

    steps:

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

      - name: Get the root API URL
        id: get-api-url
        run: |
          ROOT_API_URL=$(aws cloudformation list-exports --query "Exports[?Name=='ApiUrl'].Value" --no-paginate --output text)
          echo "ROOT_API_URL=${ROOT_API_URL}" >> $GITHUB_OUTPUT

      - name: Get the root hosting URL
        id: get-hosting-url
        run: |
          ROOT_HOSTING_URL=$(aws cloudformation list-exports --query "Exports[?Name=='HostingUrl'].Value" --no-paginate --output text)
          echo "ROOT_HOSTING_URL=${ROOT_HOSTING_URL}" >> $GITHUB_OUTPUT


  build-packages:
    name: Build/zip API for Lambda
    runs-on: ubuntu-latest
    environment: AWS_Development

    steps:
      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Install Node.js version ${{ vars.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ vars.NODE_VERSION }}

      - name: Set NODE_ENV for production
        run: echo "NODE_ENV=production" >> $GITHUB_ENV
        if: github.ref_name == 'main'
      - name: Set NODE_ENV for development
        run: echo "NODE_ENV=development" >> $GITHUB_ENV
        if: github.ref_name != 'main'

      - name: Install dependencies
        working-directory: api
        run: npm ci

      - name: Generate Prisma client
        working-directory: api
        run: npx prisma generate

      - name: Bundle and minify TypeScript (production build)
        working-directory: api
        run: npm run build-main
        if: github.ref_name == 'main'

      - name: Bundle and sourcemap TypeScript (development build)
        working-directory: api
        run: npm run build
        if: github.ref_name != 'main'

      - name: Copy Prisma client (external dependencies) to distribution context in AWS hierarchy
        run: |
          mkdir -p dist/api/nodejs/node18/node_modules && cp -r api/node_modules/{@prisma,.prisma} dist/api/nodejs/node18/node_modules/

      - name: Remove extraneous native Prisma query engines
        working-directory: dist/api/nodejs/node18/node_modules/.prisma/client
        run: rm libquery_engine-debian*

      - name: Zip API package
        working-directory: dist/api
        run: zip -9 ../api.zip index.cjs
      - name: Zip external dependency package
        working-directory: dist/api
        run: zip -9 -r ../api-ext-deps.zip nodejs

      - name: Upload API package as artifact
        uses: actions/upload-artifact@v3
        with:
          name: api
          path: dist/api.zip
      - name: Upload external dependency package as artifact
        uses: actions/upload-artifact@v3
        with:
          name: api-ext-deps
          path: dist/api-ext-deps.zip

  deploy-handler:
    name: Configure Lambda handler
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - get-names

    steps:

      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

      - name: Deploy handler stack
        env:
          CF_TAGS: prouduct=DsireApi
        working-directory: aws/CloudFormation
        run: |
          aws cloudformation deploy --template-file DsireApiHandler.yaml \
              --parameter-overrides Name=${{ needs.get-names.outputs.NAME }} \
              --stack-name ${{ needs.get-names.outputs.HANDLER_STACK }} \
              --tags "${CF_TAGS}" --no-fail-on-empty-changeset

  deploy-api:
      name: Deploy API on Lambda
      runs-on: ubuntu-latest
      environment: AWS_Development
      needs:
        - get-names
        - build-packages
        - deploy-handler

      steps:

        - name: Download API package as artifact
          uses: actions/download-artifact@v3
          with:
            name: api
        - name: Download external dependency package as artifact
          uses: actions/download-artifact@v3
          with:
            name: api-ext-deps

        - name: Configure AWS credentials
          uses: aws-actions/configure-aws-credentials@v2
          with:
            aws-region: ${{ vars.AWS_REGION }}
            role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

        - name: Get dependency layer ARN
          # The handler name is the same as the layer name (DsireApiHandler.yaml)
          # Have to query the old ARN this way as publish-layer-version doesn't want the versioned ARN
          # But we can get the new (versioned) ARN from that command because update-function-configuration does :)
          # So OLD_DEPENDENCIES_ARN is non-versioned layer ARN; DEPENDENCIES_ARN is versioned layer ARN
          run: |
            OLD_DEPENDENCIES_ARN=$(aws lambda list-layers --query "Layers[?LayerName=='${{ needs.get-names.outputs.HANDLER }}'].LayerArn" --no-paginate --output text)
            echo "OLD_DEPENDENCIES_ARN=${OLD_DEPENDENCIES_ARN}" >> $GITHUB_ENV

        - name: Create new dependency layer
          run: |
            DEPENDENCIES_ARN=$(aws lambda publish-layer-version \
                --layer-name "${OLD_DEPENDENCIES_ARN}" \
                --zip-file 'fileb://api-ext-deps.zip' \
                --query LayerVersionArn --no-paginate --output text)
            echo "DEPENDENCIES_ARN=${DEPENDENCIES_ARN}" >> $GITHUB_ENV

        - name: Deploy dependency layer on Lambda
          run: |
            aws lambda update-function-configuration --function-name="${{ needs.get-names.outputs.HANDLER }}" --layers "${DEPENDENCIES_ARN}" > /dev/null
            aws lambda wait function-updated --function-name="${{ needs.get-names.outputs.HANDLER }}"

        - name: Deploy API on Lambda
          run: |
            aws lambda update-function-code --function-name="${{ needs.get-names.outputs.HANDLER }}" --zip-file 'fileb://api.zip' > /dev/null
            aws lambda wait function-updated --function-name="${{ needs.get-names.outputs.HANDLER }}"

  sync-environment:
    name: Sync env to Lambda
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - get-names
      - get-urls
      - deploy-api

    steps:

      - name: Set APPROVER_EMAIL for production
        run: echo "APPROVER_EMAIL=${{ secrets.APPROVER_EMAIL }}" >> $GITHUB_ENV
        if: github.ref_name == 'main'
      - name: Set APPROVER_EMAIL for development
        run: echo "APPROVER_EMAIL=${{ secrets.APPROVER_EMAIL_development }}" >> $GITHUB_ENV
        if: github.ref_name != 'main'

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

      - name: Sync all environment variables with Lambda handlers
        env:
          API_URL: ${{ needs.get-urls.outputs.API }}
          APPROVER_EMAIL: ${{ env.APPROVER_EMAIL }}
          DB_URI: ${{ secrets.DB_URI }}
          HOSTING_URL: ${{ needs.get-urls.outputs.HOSTING }}
          IDENTITY_EMAIL: ${{ secrets.IDENTITY_EMAIL }}
          NODE_OPTIONS: ${{ vars.NODE_OPTIONS }}
          PUBLIC_KEY: ${{ vars.PUBLIC_KEY_JWK }}
          PRIVATE_KEY: ${{ secrets.PRIVATE_KEY_JWK }}
          SIGNING_SECRET: ${{ secrets.SIGNING_SECRET }}
          SMTP_USERNAME: ${{ secrets.SMTP_USERNAME }}
          SMTP_PASSWORD: ${{ secrets.SMTP_PASSWORD }}
        run: |
          aws lambda update-function-configuration \
              --function-name=${{ needs.get-names.outputs.HANDLER }} \
              --environment "Variables={API_URL='${API_URL}',
                                        APPROVER_EMAIL='${APPROVER_EMAIL}',
                                        DB_URI='${DB_URI}',
                                        HOSTING_URL='${HOSTING_URL}',
                                        IDENTITY_EMAIL='${IDENTITY_EMAIL}',
                                        NODE_OPTIONS='${NODE_OPTIONS}',
                                        PUBLIC_KEY='${PUBLIC_KEY}',
                                        PRIVATE_KEY='${PRIVATE_KEY}',
                                        SIGNING_SECRET='${SIGNING_SECRET}',
                                        SMTP_USERNAME='${SMTP_USERNAME}',
                                        SMTP_PASSWORD='${SMTP_PASSWORD}'}" > /dev/null
          aws lambda wait function-updated --function-name ${{ needs.get-names.outputs.HANDLER }}


  build-content:
    name: Build static content
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - get-urls

    steps:
      - name: Checkout branch ${{ github.ref_name }}
        uses: actions/checkout@v3

      - name: Install Node.js version ${{ vars.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ vars.NODE_VERSION }}

      - name: Set NODE_ENV for production
        run: echo "NODE_ENV=production" >> $GITHUB_ENV
        if: github.ref_name == 'main'
      - name: Set NODE_ENV for development
        run: echo "NODE_ENV=development" >> $GITHUB_ENV
        if: github.ref_name != 'main'

      - name: Install dependencies
        working-directory: frontend
        run: npm ci

      - name: Build CSS
        working-directory: frontend
        run: npm run build-css

      - name: Build GraphiQL
        working-directory: frontend
        run: npm run build-graphiql

      - name: Render content
        env:
          API_URL: ${{ needs.get-urls.outputs.API }}
          GCP_SITE_KEY: ${{ vars.GCP_SITE_KEY }}
          REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ env.GITHUB_SHA }}
        working-directory: frontend
        run: npm run render

      - name: Upload content as artifact
        uses: actions/upload-artifact@v3
        with:
          name: frontend
          path: dist/frontend/*

  sync-content:
    name: Sync content with S3
    runs-on: ubuntu-latest
    environment: AWS_Development
    needs:
      - get-names
      - build-content

    steps:

      - name: Download content as artifact
        uses: actions/download-artifact@v3
        with:
          name: frontend

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-region: ${{ vars.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}

      - name: Sync content with S3
        run: aws s3 sync --size-only --delete . s3://${{ vars.HOSTING_BUCKET }}/${{ needs.get-names.outputs.NAME }}/
